#include <iostream>
#include <ctime>
using namespace std;

class psevdo_int {
public:
	psevdo_int(int x) {
		this->x = x;
	}

	psevdo_int(psevdo_int const& other) {
		this->x = other.x + 1;
	}

	int x;
};

class psevdo_int2 {
public:
	psevdo_int2(int x) {
		this->x = x;
	}

	int x;
};


//========================================================================================================================================================

class dinamic_array {
public:
	dinamic_array(int size) {
		int* data = new int[size];
		for (int i = 0; i < size; ++i) {
			data[i] = rand();
		}

		this->size = size;
		this->data = data;
	}

	/* Если конструктор не объявлен - это всё равно, что сделать его таким
	dinamic_array(dinamic_array const& other) {
		this->data = other.data;
	}
	*/

	~dinamic_array() { // деструктор нужен для освобождения памяти, выделенной под массив, если его не определить, удалится только значение адреса в data
		delete[] data;
		data = nullptr; // значение указателя меняется только в текущем объекте. если существуют копии, то в них значение указателя будет прежнее
		// если копия будет удаляться, то будет совершена повторная попытка освобождения памяти.
	}

	int size;
	int* data;
};

class dinamic_array2 {
public:
	dinamic_array2(int size) {
		int* data = new int[size];
		for (int i = 0; i < size; ++i) {
			data[i] = rand();
		}

		this->size = size;
		this->data = data;
	}

	dinamic_array2(dinamic_array2 const& other) {
		int* data = new int[other.size];
		for (int i = 0; i < other.size; ++i) {
			data[i] = other.data[i];
		}

		this->size = other.size;
		this->data = data;
	}

	~dinamic_array2() { // деструктор нужен для освобождения памяти, выделенной под массив, если его не определить, удалится только значение адреса в data
		delete[] data;
		data = nullptr; // значение указателя меняется только в текущем объекте. если существуют копии, то в них значение указателя будет ненулевое
	}

	int size;
	int* data;
};

int main() {
	setlocale(LC_ALL, "ru");
	srand(time(NULL));

	cout << "Неопределенный конструктор копирования: " << endl;
	psevdo_int2 c(2);
	psevdo_int2 d(c);
	cout << "Значение, хранящееся в исходном объекте: x = " << c.x << endl;
	cout << "Значение, хранящееся в скопированном объекте: x = " << d.x << endl << endl;

	cout << "Определенный коснтруктор копирования: " << endl;
	psevdo_int a(12);
	psevdo_int b(a);
	cout << "Значение, хранящееся в исходном объекте: x = " << a.x << endl;
	cout << "Значение, хранящееся в скопированном объекте: x = " << b.x << endl << endl;

	/*При копировании объекта в новую переменную без определения конструктора копирования, создается точная побитовая копия объекта. Если объект содержит только int
	значение, как в первом случае, то в памяти программы создастся новый объект, в который запишется то же самое значение int. Но предположим, что объект содержит не
	значение int, а указатель на массив в динамической памяти.

	Выделение памяти под массив происходит в обычном конструкторе. Проблема в том, что он не вызывается при вызове другого конструктора (конструктора копирования),
	поскольку входной параметр конструктора - это не size, а объект, который мы копируем. Компилятор не ругается на такой параметр (объект) потому, что существует
	такой конструктор по умолчанию. Он создает побитовую копию того объекта, который мы копируем. То есть мы скопируем только поля этого объекта, в частности, указатель
	на массив.

	Во втором объекте будет тот же самый указатель на массив, что и в первом случае. Для каждого из объектов вызовится деструктор, и они будут пытаться удалить один и тот
	же объект.
	*/

	/*
	dinamic_array arr1(10); // Последним деструктором вызывается деструктор объекта arr1. Поскольку поле data в arr1 и arr2 идентичны, деструктор не сможет второй раз
	//освободить память по адресу data. Это приведет к ошибке.
	dinamic_array arr2(arr1); //Третьим деструктором вызывается деструктор объекта arr2 и освобождается память по указателю arr2.data.
	cout << arr1.data << '\t' << arr2.data << endl;
	*/

	dinamic_array2 arr3(10); //Вторым деструктором вызывается деструктор этого объекта, он освобождает память по указателю arr3.data.
	dinamic_array2 arr4(arr3); //Сначала вызывается деструктор этого объекта, он освобождает динамическую память по указателю arr4.data.
	cout << arr3.data << '\t' << arr4.data << endl;

	return 0;
}